/* Copyright 2020 Sergei Bastrakov
 *
 * This file is part of PIConGPU.
 *
 * PIConGPU is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PIConGPU is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PIConGPU.
 * If not, see <http://www.gnu.org/licenses/>.
 */

#pragma once

#include "picongpu/simulation_defines.hpp"

#include "picongpu/traits/frame/GetMass.hpp"

#include <pmacc/mappings/kernel/AreaMapping.hpp>

#include <cstdint>


namespace picongpu
{
namespace particles
{
namespace debyeLength
{
namespace detail
{

    //! Debye length check kernel result
    struct Result
    {
        //! Number of supercells with electrons
        uint32_t numActiveSupercells = 0u;

        //! Number of supercells violating Debye length resolution check
        uint32_t numViolatingSupercells = 0u;
    };

    /** Kernel to check Debye length for electrons
     *
     * @tparam T_numWorkers number of threads per block
     */
    template< uint32_t T_numWorkers >
    struct DebyeLengthCheckKernel
    {

        /** Kernel to check Debye length for electrons
         *
         * @tparam T_Acc alpaka accelerator type
         * @tparam T_ElectronBox electron storage type
         * @tparam T_Mapping mapping type
         * @tparam T_ResultBox result storage type, device box for Result
         *
         * @param acc alpaka accelerator
         * @param electronBox electron storage
         * @param mapper mapping
         * @param result device box of type Result with a single element
         *        to write kernel result to
         */
        template<
            typename T_Acc,
            typename T_ElectronBox,
            typename T_Mapping,
            typename T_ResultBox
        >
        DINLINE void operator()(
            T_Acc const & acc,
            T_ElectronBox const electronBox,
            T_Mapping mapper,
            T_ResultBox result
        ) const
        {
            auto const supercellIdx = mapper.getSuperCellIndex(
                DataSpace< simDim >( cupla::blockIdx( acc ) )
            );
            auto const & supercell = electronBox.getSuperCell( supercellIdx );
            // Supercells with no particles do not contribute to Debye length estimate
            if( supercell.getNumParticles() )
                process(
                    acc,
                    electronBox,
                    supercellIdx,
                    result
                );
        }

    private:

        /** Check Debye length for electrons in the given supercell
         *
         * Ths supercell is required to have macroparticles
         *
         * @tparam T_Acc alpaka accelerator type
         * @tparam T_ElectronBox electron storage type
         * @tparam T_ResultBox result storage type, device box for Result
         *
         * @param acc alpaka accelerator
         * @param electronBox electron storage
         * @param supercellIdx supercell index, including guards
         * @param result device box of type Result with a single element
         *        to write kernel result to
         */
        template<
            typename T_Acc,
            typename T_ElectronBox,
            typename T_ResultBox
        >
        DINLINE void process(
            T_Acc const & acc,
            T_ElectronBox const electronBox,
            pmacc::DataSpace< simDim > const supercellIdx,
            T_ResultBox result
        ) const
        {
            using namespace pmacc::mappings::threads;
            constexpr uint32_t frameSize = pmacc::math::CT::volume< SuperCellSize >::type::value;
            constexpr uint32_t numWorkers = T_numWorkers;
            using ParticleDomCfg = IdxConfig<
                frameSize,
                numWorkers
            >;
            // Use double-precision for better accuracy, this kernel is not performance-critical
            auto sumMomentum = float3_64::create( 0.0 );
            auto sumMomentumSquared = float3_64::create( 0.0 );
            auto frame = electronBox.getLastFrame( supercellIdx );
            auto particlesInFrame = electronBox.getSuperCell( supercellIdx ).getSizeLastFrame( );
            uint32_t const workerIdx = cupla::threadIdx( acc ).x;
            while( frame.isValid( ) )
            {
                // parallel loop over all particles in the frame
                ForEachIdx< ParticleDomCfg >{ workerIdx }
                (
                    [&](
                        uint32_t const linearIdx,
                        uint32_t const
                    )
                    {
                        if( linearIdx < particlesInFrame )
                        {
                            auto const particle = frame[ linearIdx ];
                            // the evaluation is based on single- (not macro-) particle momentums
                            auto const singleParticleMomentum =
                                precisionCast< float_64 >( particle[ momentum_ ] ) /
                                precisionCast< float_64 >( particle[ weighting_ ] );
                            sumMomentum += singleParticleMomentum;
                            sumMomentumSquared += singleParticleMomentum * singleParticleMomentum;
                        }
                    }
                );
                frame = electronBox.getPreviousFrame( frame );
                particlesInFrame = frameSize;
            }

            // Reduce for supercell in shared memory
            PMACC_SMEM( acc, supercellSumMomentum, float3_64 );
            PMACC_SMEM( acc, supercellSumMomentumSquared, float3_64 );
            ForEachIdx<
                IdxConfig<
                    1,
                    numWorkers
                >
            > onlyMaster{ workerIdx };
			onlyMaster(
			    [&](
			        uint32_t const,
			        uint32_t const
			    )
			    {
			        supercellSumMomentum = float3_64::create( 0.0 );
                    supercellSumMomentumSquared = float3_64::create( 0.0 );
			    }
			);
            cupla::__syncthreads( acc );
            for( uint32_t d = 0; d < 3; d++ )
            {
                cupla::atomicAdd(
                    acc,
                    &( supercellSumMomentum[ d ] ),
                    sumMomentum[ d ],
                    ::alpaka::hierarchy::Threads{}
                );
                cupla::atomicAdd(
                    acc,
                    &( supercellSumMomentumSquared[ d ] ),
                    sumMomentumSquared[ d ],
                    ::alpaka::hierarchy::Threads{}
                );
            }
            cupla::__syncthreads( acc );
            onlyMaster(
			    [&](
			        uint32_t const,
			        uint32_t const
			    )
			    {
                    auto numParticles = static_cast< float_64 >(
                        electronBox.getSuperCell( supercellIdx ).getNumParticles()
                    );
                    auto const mean = supercellSumMomentum / numParticles;
                    auto const vectorVariance = supercellSumMomentumSquared / numParticles - mean * mean;
                    // For the estimate, we need scalar variance, so use average
                    auto const variance = ( vectorVariance[ 0 ] +
                        vectorVariance[ 1 ] + vectorVariance[ 2 ] ) / 3.0;
                    check(
                        acc,
                        electronBox,
                        supercellIdx,
                        variance,
                        result
                    );
			    }
			);
        }

        /** Check Debye length and write back results
         *
         * This function makes an estimate for the whole provided electron box,
         * and so must be called once per non-empty supercell.
         *
         * @tparam T_Acc alpaka accelerator type
         * @tparam T_ElectronBox electron storage type
         * @tparam T_ResultBox result storage type, device box for Result
         *
         * @param acc alpaka accelerator
         * @param electronBox electron storage
         * @param supercellIdx supercell index, including guards
         * @param momentumVariance estimated variance in physical momentums
         * @param result device box of type Result with a single element
         *        to write kernel result to
         */
        template<
            typename T_Acc,
            typename T_ElectronBox,
            typename T_ResultBox
        >
        DINLINE void check(
            T_Acc const & acc,
            T_ElectronBox const electronBox,
            pmacc::DataSpace< simDim > const supercellIdx,
            double momentumVariance,
            T_ResultBox result
        ) const
        {
            auto numParticles = static_cast< float_64 >(
                electronBox.getSuperCell( supercellIdx ).getNumParticles()
            );
            auto const supercellVolume = CELL_VOLUME *
                precisionCast< float_64 >( SuperCellSize::toRT().productOfComponents() );
            auto const electronDensity = numParticles / supercellVolume;

            /* For the Maxwell-Boltzmann distribution,
             * variance = mass * k * T, both for physical and macroparticle.
             * We assume this distribution and estimate k * T out of variance
             */
            using Frame = typename T_ElectronBox::FrameType;
            auto const mass = static_cast< double >(
                picongpu::traits::frame::getMass< Frame >( )
            );
            auto const kT = momentumVariance / mass;
            auto const electronCharge = picongpu::traits::frame::getCharge< Frame >( );
            auto const debyeLength = sqrt(
                EPS0 * kT / ( electronDensity * electronCharge * electronCharge )
            );

            auto maxCellSize = cellSize[ 0 ];
            for( uint32_t d = 1; d < simDim; d++ )
                maxCellSize = math::max( maxCellSize, cellSize[ d ] );
            auto const minCellsPerDebyeLength = 2.0;
            auto const thresholdSize = maxCellSize * minCellsPerDebyeLength;
            auto const isResolved = ( debyeLength / thresholdSize >= 1 );

            if( !isResolved )
                cupla::atomicAdd(
                    acc,
                    &( result( 0 ).numViolatingSupercells ),
                    1u,
                    ::alpaka::hierarchy::Blocks{}
                );
            cupla::atomicAdd(
                acc,
                &( result( 0 ).numActiveSupercells ),
                1u,
                ::alpaka::hierarchy::Blocks{}
            );
        }

    };

} // namespace detail
} // namespace debyeLength
} // namespace particles
} // namespace picongpu
