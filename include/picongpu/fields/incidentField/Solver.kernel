/* Copyright 2020-2021 Sergei Bastrakov
 *
 * This file is part of PIConGPU.
 *
 * PIConGPU is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PIConGPU is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PIConGPU.
 * If not, see <http://www.gnu.org/licenses/>.
 */

#pragma once

#include "picongpu/simulation_defines.hpp"

#include "picongpu/fields/differentiation/Derivative.hpp"
#include "picongpu/fields/incidentField/DerivativeCoefficients.hpp"

#include <cstdint>


namespace picongpu
{
    namespace fields
    {
        namespace incidentField
        {
            namespace detail
            {
                /** Helper functor for in-kernel update of the given field using the given incident field functor
                 *
                 * Performs update by adding terms with the incident field.
                 * The positions, indices and coefficients for these terms are determined by members.
                 *
                 * @tparam T_UpdatedFieldBox updated field box type
                 * @tparam T_CurlIncidentField curl(incidentField) functor type
                 * @tparam T_FunctorIncidentField incident field source functor type
                 * @tparam T_axis boundary axis, 0 = x, 1 = y, 2 = z
                 */
                template<
                    typename T_UpdatedFieldBox,
                    typename T_CurlIncidentField,
                    typename T_FunctorIncidentField,
                    uint32_t T_axis>
                struct UpdateFunctor
                {
                    /** Create an update functor instance on the host side
                     *
                     * It should then be passed to the kernel by value
                     *
                     * @param unitField conversion factor from SI to internal units,
                     *                  field_internal = field_SI / unitField
                     */
                    UpdateFunctor(float3_64 const unitField)
                        : functorIncidentField(unitField)
                        , coeff1(float3_X::create(0.0_X))
                        , coeff2(float3_X::create(0.0_X))
                    {
                    }

                    /** Update field at the given grid index
                     *
                     * @param gridIdx grid index in the local domain, including guards
                     */
                    HDINLINE void operator()(pmacc::DataSpace<simDim> const& gridIdx)
                    {
                        // Fractional since the later shift is fractional
                        auto const incidentFieldShiftBase
                            = pmacc::algorithms::precisionCast::precisionCast<float_X>(gridIdx + gridIdxShift);
                        auto const incidentFieldShift1 = incidentFieldShiftBase + inCellShift1;
                        auto const incidentFieldShift2 = incidentFieldShiftBase + inCellShift2;
                        /* Update all field values within margin - 1 cells in both sides of gridIdx along the axis.
                         * We do not need any synchronization here, as the kernel distributes work along
                         * the other two axes. So all grid values in this "row" along the axis will be touched by one
                         * thread.
                         */
                        for(int32_t updatedFieldShift = 1 - margin; updatedFieldShift < margin; updatedFieldShift++)
                        {
                            auto updatedFieldIdx = gridIdx;
                            updatedFieldIdx[axis] += updatedFieldShift;
                            updatedField(updatedFieldIdx) += getUpdatedFieldCorrection(
                                updatedFieldShift,
                                incidentFieldShift1,
                                incidentFieldShift2);
                        }
                    }

                    //! Updated field box
                    T_UpdatedFieldBox updatedField;

                    //! Derivative functor along T_axis type
                    using DerivativeFunctor
                        = differentiation::DerivativeFunctor<typename T_CurlIncidentField::Derivative, T_axis>;

                    //! Derivative coefficients type
                    using Coefficients = DerivativeCoefficients<DerivativeFunctor, T_axis>;

                    //! Number of derivative coefficients type
                    using NumCoefficients = typename Coefficients::Size;

                    //! Defivative coefficients instance
                    Coefficients const derivativeCoefficients;

                    /** Margin of the scheme along T_axis
                     *
                     * Signed to simplify index calculations with shifts of both signs
                     */
                    static constexpr int32_t margin = pmacc::math::CT::At_c<NumCoefficients, T_axis>::type::value;

                    //! Incident field functor
                    T_FunctorIncidentField functorIncidentField;

                    //! Indices of the incident field components for the two terms
                    uint32_t incidentComponent1, incidentComponent2;

                    /** Coefficients for two functorIncidentField invocations assuming Yee field solver
                     *
                     * The coefficients have a single non-zero component (different between those two).
                     * Thus, they define both the updated field component and the corresponding coefficient.
                     */
                    float3_X coeff1, coeff2;

                    //! Shifts inside the cell for two functorIncidentField invocations, in cells
                    floatD_X inCellShift1, inCellShift2;

                    //! Index shift: totalCellIdx (that a user functor gets) = gridIdx + gridIdxShirt
                    pmacc::DataSpace<simDim> gridIdxShift;

                    //! Current time step, in iterations; can be fractional
                    float_X currentStep;

                    /** Direction of the incident field propagation
                     *
                     * +1._X is positive direction (from the min boundary inwards).
                     * -1._X is negative direction (from the max boundary inwards)
                     */
                    float_X direction;

                    //! Boundary axis, 0 = x, 1 = y, 2 = z
                    static constexpr uint32_t axis = T_axis;

                    //! Whether the updated field is total or scattered
                    bool isUpdatedFieldTotal;

                private:
                    /** Calculate correction for the updated field due to incident field for the given shift
                     *
                     * All shifts are in cells, relative to the base position corresponding to the Yee solver.
                     *
                     * The correction is calculated as follows.
                     * We consider all grid nodes of the incident field involved in finite-difference calculation of
                     * d(incidentField)/d(T_axis) at the given position of the updated field.
                     * Out of those nodes, we only use ones on the opposite side of the Huygens surface from the
                     * updated field position.
                     * Incident field values are evaluated on those places and accumulated with coefficients
                     * derived from the curl coefficients.
                     * The total coefficient in front of incident field over all updatedFieldShift values
                     * is the same for all schemes.
                     * The difference between schemes is basically in how it is scattered betweeen the nodes.
                     *
                     * @param updatedFieldShift shift of the updated field along the axis relative to the base position
                     * @param incidentFieldShift1 base shift of the first incident field component
                     * @param incidentFieldShift2 base shift of the second incident field component
                     */
                    HDINLINE float3_X getUpdatedFieldCorrection(
                        int32_t updatedFieldShift,
                        floatD_X const& incidentFieldShift1,
                        floatD_X const& incidentFieldShift2) const
                    {
                        auto result = float3_X::create(0.0_X);
                        auto incidentIdxShift = floatD_X::create(0.0_X);
                        incidentIdxShift[axis] = getInitialIncidentFieldShift(updatedFieldShift);
                        auto const incidentIdxShiftIncrement = getIncidentFieldShiftIncrement(updatedFieldShift);

                        /* To unify implementation for 2d and 3d, derivative coefficients and this function always
                         * operate as if in 3d.
                         * For 2d the z loop is always for a single iteration.
                         * The resulting 3d indices and shrinked to simDim.
                         */
                        constexpr auto dir1 = (axis + 1) % 3;
                        constexpr auto dir2 = (axis + 2) % 3;
                        constexpr int32_t sizeDir1 = pmacc::math::CT::At_c<NumCoefficients, dir1>::type::value;
                        constexpr int32_t sizeDir2 = pmacc::math::CT::At_c<NumCoefficients, dir2>::type::value;
                        for(int32_t axisShift = abs(updatedFieldShift); axisShift < margin; axisShift++)
                        {
                            auto coeffIdx = pmacc::DataSpace<3>::create(0);
                            coeffIdx[axis] = axisShift;
                            incidentIdxShift[dir1] = static_cast<float_X>(1 - sizeDir1);
                            for(int32_t dir1Shift = 1 - sizeDir1; dir1Shift < sizeDir1; dir1Shift++)
                            {
                                coeffIdx[dir1] = abs(dir1Shift);
                                incidentIdxShift[dir2] = static_cast<float_X>(1 - sizeDir2);
                                for(int32_t dir2Shift = 1 - sizeDir2; dir2Shift < sizeDir2; dir2Shift++)
                                {
                                    coeffIdx[dir2] = abs(dir2Shift);
                                    auto const derivativeCoeff
                                        = derivativeCoefficients.value[coeffIdx[0]][coeffIdx[1]][coeffIdx[2]];
                                    result += derivativeCoeff
                                        * (coeff1
                                               * functorIncidentField(
                                                   incidentFieldShift1 + incidentIdxShift.shrink<simDim>(),
                                                   currentStep)[incidentComponent1]
                                           + coeff2
                                               * functorIncidentField(
                                                   incidentFieldShift2 + incidentIdxShift.shrink<simDim>(),
                                                   currentStep)[incidentComponent2]);
                                    incidentIdxShift[dir2] += 1.0_X;
                                }
                                incidentIdxShift[dir1] += 1.0_X;
                            }
                            incidentIdxShift[axis] += incidentIdxShiftIncrement;
                        }
                        return result;
                    }

                    /** Calculate incident field shift increment for the given updated field shift
                     *
                     * Both shifts are along T_axis, in cells, relative to the scheme for the classic Yee solver.
                     * The incident field shift is moving the opposite side from the updated field shift.
                     * For zero update field shift, this side is always towards outwards and
                     * depending on TF or SF region, it aligns or counter-aligns with this->direction.
                     *
                     * @param updatedFieldShift shift of the updated field along the axis relative to the base position
                     */
                    HDINLINE float_X getIncidentFieldShiftIncrement(int32_t updatedFieldShift) const
                    {
                        if(updatedFieldShift < 0)
                            return 1.0_X;
                        else if(updatedFieldShift > 0)
                            return -1.0_X;
                        else
                            return isUpdatedFieldTotal ? -direction : direction;
                    }

                    /** Calculate initial incident field shift for the given updated field shift
                     *
                     * Both shifts are along T_axis, in cells, relative to the scheme for the classic Yee solver.
                     * The incident field shift is moving the opposite side from the updated field shift.
                     * It has to be adjusted by one based on TF or SF region and direction.
                     *
                     * @param updatedFieldShift shift of the updated field along the axis relative to the base position
                     */
                    HDINLINE float_X getInitialIncidentFieldShift(int32_t updatedFieldShift) const
                    {
                        auto result = static_cast<float_X>(-updatedFieldShift);
                        if((isUpdatedFieldTotal) && (updatedFieldShift * direction > 0))
                            result += direction;
                        if((!isUpdatedFieldTotal) && (updatedFieldShift * direction < 0))
                            result -= direction;
                        return result;
                    }
                };

                /** Kernel to apply incident field
                 *
                 * @tparam T_numWorkers number of workers
                 * @tparam T_BlockDescription domain description
                 */
                template<uint32_t T_numWorkers, typename T_BlockDescription>
                struct ApplyIncidentFieldKernel
                {
                    /** Run the incident field kernel
                     *
                     * @tparam T_Acc alpaka accelerator type
                     * @tparam T_UpdateFunctor update functor type
                     *
                     * @param acc alpaka accelerator
                     * @param functor update functor
                     * @param beginGridIdx begin active grid index, in the local domain with guards
                     * @param endGridIdx end active grid index, in the local domain with guards
                     */
                    template<typename T_Acc, typename T_UpdateFunctor>
                    HDINLINE void operator()(
                        T_Acc& acc,
                        T_UpdateFunctor functor,
                        DataSpace<simDim> beginGridIdx,
                        DataSpace<simDim> endGridIdx) const
                    {
                        constexpr uint32_t planeSize = pmacc::math::CT::volume<T_BlockDescription>::type::value;
                        const uint32_t workerIdx = cupla::threadIdx(acc).x;

                        // Offset of the superCell (in cells, without any guards) to the origin of the local domain
                        DataSpace<simDim> supercellOffsetCells
                            = DataSpace<simDim>(cupla::blockIdx(acc)) * SuperCellSize::toRT();

                        lockstep::makeForEach<planeSize, T_numWorkers>(workerIdx)(
                            [&](uint32_t const linearIdx)
                            {
                                auto cellIdxInSuperCell
                                    = DataSpaceOperations<simDim>::template map<T_BlockDescription>(linearIdx);
                                auto const gridIdx = beginGridIdx + supercellOffsetCells + cellIdxInSuperCell;

                                // The index may be outside since the active area is not generally a multiple of block
                                // size
                                bool isInside = true;
                                for(uint32_t d = 0; d < simDim; d++)
                                    isInside = isInside && (gridIdx[d] < endGridIdx[d]);
                                if(isInside)
                                    functor(gridIdx);
                            });
                    }
                };

            } // namespace detail
        } // namespace incidentField
    } // namespace fields
} // namespace picongpu
