/* Copyright 2020-2021 Sergei Bastrakov
 *
 * This file is part of PIConGPU.
 *
 * PIConGPU is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PIConGPU is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PIConGPU.
 * If not, see <http://www.gnu.org/licenses/>.
 */

#pragma once

#include "picongpu/simulation_defines.hpp"

#include "picongpu/fields/differentiation/Derivative.hpp"
#include "picongpu/fields/incidentField/DerivativeCoefficients.hpp"

#include <cstdint>


namespace picongpu
{
    namespace fields
    {
        namespace incidentField
        {
            namespace detail
            {
                /** Helper functor for in-kernel update of the given field using the given incident field functor
                 *
                 * Performs update by adding terms with the incident field.
                 * The positions, indices and coefficients for these terms are determined by members.
                 *
                 * @tparam T_UpdatedFieldBox updated field box type
                 * @tparam T_CurlIncidentField curl(incidentField) functor type
                 * @tparam T_FunctorIncidentField incident field source functor type
                 * @tparam T_axis boundary axis, 0 = x, 1 = y, 2 = z
                 */
                template<
                    typename T_UpdatedFieldBox,
                    typename T_CurlIncidentField,
                    typename T_FunctorIncidentField,
                    uint32_t T_axis>
                struct UpdateFunctor
                {
                    /** Create an update functor instance
                     *
                     * @param unitField conversion factor from SI to internal units,
                     *                  field_internal = field_SI / unitField
                     */
                    HDINLINE UpdateFunctor(float3_64 const unitField)
                        : functorIncidentField(unitField)
                        , coeff1(float3_X::create(0.0_X))
                        , coeff2(float3_X::create(0.0_X))
                    {
                    }

                    /** Calculate initial incident field shift for the given updated field shift
                     *
                     * Both shifts are along T_axis, in cells, relative to the scheme for the classic Yee solver.
                     * The incident field shift is moving the opposite side from the updated field shift.
                     * It has to be adjusted by one based on TF or SF region and direction.
                     *
                     * @param updatedFieldShift shift of the updated field
                     */
                    HDINLINE float_X getInitialIncidentFieldShift(int32_t updatedFieldShift) const
                    {
                        auto result = static_cast<float_X>(-updatedFieldShift);
                        if((isUpdatedFieldTotal) && (updatedFieldShift * direction > 0))
                            result += direction;
                        if((!isUpdatedFieldTotal) && (updatedFieldShift * direction < 0))
                            result -= direction;
                        return result;
                    }

                    /** Calculate incident field shift increment for the given updated field shift
                     *
                     * Both shifts are along T_axis, in cells, relative to the scheme for the classic Yee solver.
                     * The incident field shift is moving the opposite side from the updated field shift.
                     * For zero update field shift, this side is always towards outwards and
                     * depending on TF or SF region, it aligns or counter-aligns with this->direction.
                     *
                     * @param updatedFieldShift index in the outer loop
                     */
                    HDINLINE float_X getIncidentFieldShiftIncrement(int32_t updatedFieldShift) const
                    {
                        if(updatedFieldShift < 0)
                            return 1.0_X;
                        else if(updatedFieldShift > 0)
                            return -1.0_X;
                        else
                            return isUpdatedFieldTotal ? -direction : direction;
                    }

                    /** Update field at the given grid index
                     *
                     * @param gridIdx grid index in the local domain, including guards
                     */
                    HDINLINE void operator()(pmacc::DataSpace<simDim> const& gridIdx)
                    {
                        // Fractional since the later shift is fractional
                        auto const cellIdxBase
                            = pmacc::algorithms::precisionCast::precisionCast<float_X>(gridIdx + gridIdxShift);
                        auto const cellIdx1 = cellIdxBase + inCellShift1;
                        auto const cellIdx2 = cellIdxBase + inCellShift2;
                        /* For Yee field solver we only need to update gridIdx with shift 0.
                         * For other FDTD schemes iterate symmetrically around it.
                         * The indices of the updated and incident fields counterpropagate.
                         * The implementation is generic for all solvers, the specialization is done via
                         * DerivativeCoefficients<>.
                         * Here we rely on the fact coeff1 and coeff2 are always calculated for the Yee solver.
                         * We iterate along the axis and "scatter" part of the coeff = 1 * coeff1,2 into a sum of
                         * derivativeCoefficients.values[p] that are on the other side from the Huygens surface.
                         */
                        // Convert to signed to ensure correct arithmetic with negative shifts
                        auto const numCoefficients = static_cast<int32_t>(derivativeCoefficients.size);
                        for(int32_t updatedIdxShift = 1 - numCoefficients; updatedIdxShift < numCoefficients;
                            updatedIdxShift++)
                        {
                            auto incidentIdxShift = floatD_X::create(0.0_X);
                            incidentIdxShift[axis] = getInitialIncidentFieldShift(updatedIdxShift);
                            auto const incidentIdxShiftIncrement = getIncidentFieldShiftIncrement(updatedIdxShift);
                            auto incidentField = float3_X::create(0.0_X);
                            for(int32_t p = abs(updatedIdxShift); p < numCoefficients; p++)
                            {
                                incidentField += derivativeCoefficients.values[p]
                                    * (coeff1
                                           * functorIncidentField(
                                               cellIdx1 + incidentIdxShift,
                                               currentStep)[incidentComponent1]
                                       + coeff2
                                           * functorIncidentField(
                                               cellIdx2 + incidentIdxShift,
                                               currentStep)[incidentComponent2]);
                                incidentIdxShift[axis] += incidentIdxShiftIncrement;
                            }
                            auto updatedIdx = gridIdx;
                            updatedIdx[axis] += updatedIdxShift;
                            updatedField(updatedIdx) += incidentField;
                        }
                    }

                    //! Updated field box
                    T_UpdatedFieldBox updatedField;

                    //! Derivative functor along T_axis type
                    using DerivativeFunctor
                        = differentiation::DerivativeFunctor<typename T_CurlIncidentField::Derivative, T_axis>;

                    //! Defivative coefficients
                    DerivativeCoefficients<DerivativeFunctor, T_axis> derivativeCoefficients;

                    //! Incident field functor
                    T_FunctorIncidentField functorIncidentField;

                    //! Indices of the incident field components for the two terms
                    uint32_t incidentComponent1, incidentComponent2;

                    //! Coefficients for two functorIncidentField invocations assuming Yee field solver
                    float3_X coeff1, coeff2;

                    //! Shifts inside the cell for two functorIncidentField invocations, in cells
                    floatD_X inCellShift1, inCellShift2;

                    //! Index shift: totalCellIdx (that a user functor gets) = gridIdx + gridIdxShirt
                    pmacc::DataSpace<simDim> gridIdxShift;

                    //! Current time step, in iterations; can be fractional
                    float_X currentStep;

                    /** Direction of the incident field propagation
                     *
                     * +1._X is positive direction (from the min boundary inwards).
                     * -1._X is negative direction (from the max boundary inwards)
                     */
                    float_X direction;

                    //! Boundary axis, 0 = x, 1 = y, 2 = z
                    static constexpr uint32_t axis = T_axis;

                    //! Whether the updated field is total or scattered
                    bool isUpdatedFieldTotal;
                };

                /** Kernel to apply incident field
                 *
                 * @tparam T_numWorkers number of workers
                 * @tparam T_BlockDescription domain description
                 */
                template<uint32_t T_numWorkers, typename T_BlockDescription>
                struct ApplyIncidentFieldKernel
                {
                    /** Run the incident field kernel
                     *
                     * @tparam T_Acc alpaka accelerator type
                     * @tparam T_UpdateFunctor update functor type
                     *
                     * @param acc alpaka accelerator
                     * @param functor update functor
                     * @param beginGridIdx begin active grid index, in the local domain with guards
                     * @param endGridIdx end active grid index, in the local domain with guards
                     */
                    template<typename T_Acc, typename T_UpdateFunctor>
                    HDINLINE void operator()(
                        T_Acc& acc,
                        T_UpdateFunctor functor,
                        DataSpace<simDim> beginGridIdx,
                        DataSpace<simDim> endGridIdx) const
                    {
                        constexpr uint32_t planeSize = pmacc::math::CT::volume<T_BlockDescription>::type::value;
                        const uint32_t workerIdx = cupla::threadIdx(acc).x;

                        // Offset of the superCell (in cells, without any guards) to the origin of the local domain
                        DataSpace<simDim> supercellOffsetCells
                            = DataSpace<simDim>(cupla::blockIdx(acc)) * SuperCellSize::toRT();

                        lockstep::makeForEach<planeSize, T_numWorkers>(workerIdx)(
                            [&](uint32_t const linearIdx)
                            {
                                auto cellIdxInSuperCell
                                    = DataSpaceOperations<simDim>::template map<T_BlockDescription>(linearIdx);
                                auto const gridIdx = beginGridIdx + supercellOffsetCells + cellIdxInSuperCell;

                                // The index may be outside since the active area is not generally a multiple of block
                                // size
                                bool isInside = true;
                                for(uint32_t d = 0; d < simDim; d++)
                                    isInside = isInside && (gridIdx[d] < endGridIdx[d]);
                                if(isInside)
                                    functor(gridIdx);
                            });
                    }
                };

            } // namespace detail
        } // namespace incidentField
    } // namespace fields
} // namespace picongpu
