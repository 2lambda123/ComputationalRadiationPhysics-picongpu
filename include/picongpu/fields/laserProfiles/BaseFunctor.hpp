/* Copyright 2013-2022 Axel Huebl, Heiko Burau, Rene Widera, Richard Pausch, Ilja Goethel,
 *                     Anton Helm, Alexander Debus, Sergei Bastrakov
 *
 * This file is part of PIConGPU.
 *
 * PIConGPU is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PIConGPU is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PIConGPU.
 * If not, see <http://www.gnu.org/licenses/>.
 */

#pragma once

#include "picongpu/simulation_defines.hpp"

#include "picongpu/fields/MaxwellSolver/GetTimeStep.hpp"

#include <cstdint>

namespace picongpu
{
    namespace fields
    {
        namespace laserProfiles
        {
            namespace acc
            {
                /** Base device-side functor for laser profile implementations
                 *
                 * Stores common data for all such implementations.
                 * Implements the logic of contributing the stored value to the grid value of E.
                 * Has two modes of operation depending on T_initPlaneY: a hard and a mixed hard-soft source.
                 *
                 * For the T_initPlaneY == 0 case, our laser is a classic hard source: E(y=0, t) = E_source(y=0, t).
                 * A notable disadvantage of hard sources is that they are not transparent for incoming waves
                 * (e.g. reflected from a target) while the laser is being generated as controlled by its pulse length.
                 * More details on hard sources are given in section 5.1 of the book
                 * A. Taflove, S.C. Hagness. Computational Electrodynamics. The Finite-Difference Time-Domain Method.
                 * Third Edition. Artech house, Boston (2005).
                 *
                 * Generally, hard-setting E at a hyperplane y=0 generates E waves going in +y and -y directions.
                 * Those E waves will propagate to both sides symmetrically, both theoretically and in an FDTD solver.
                 * So the corresponding field (only part generated by the source) E(y) is even wrt y: E(y) = E(-y).
                 * Therefore the FDTD-solved resulting B field is odd: B(y) = -B(-y), and particularly B(0) = 0.
                 * These relations simply follow from the way of setting the source and properties of FDTD.
                 *
                 * The above paragraph applies to a theoretical case of FDTD-propagating fields everywhere.
                 * However, it is not exactly what happens in a PIConGPU simulation.
                 * In PIConGPU, grid values to the left from the y = 0 plane are not updated by a field solver.
                 * So there will be no left-propagating wave in a simulation, only the right-propagating one.
                 * Note that it is only due to not applying a field solver, not because of a reflecting boundary.
                 * For the classic Yee solver, this scheme is completely fine.
                 * Updates for all grid values with y > 0 use only "good" values with y >= 0.
                 * These include Bx, Bz in the cell starting at y = 0 as they are located as y = dy/2.
                 * And Ex, Ez values at exactly y = 0 are overwritten with the hard source.
                 * However, this scheme is not fully accurate for wider stencils used in FDTD.
                 * In that case, some updates would use "bad" values from the y < 0 area, that are always kept 0.
                 * Thus, the laser with initPlaneY = 0 is only fully accurate with the classic Yee solver.
                 *
                 * For the T_initPlaneY > 0 case, our laser is a mixed hard-soft source.
                 * It also only affects E, but following E(y=0, t) += coefficient * E_source(y=0, t).
                 * Beware a principle difference of this scheme from classic soft sources.
                 * Those are formulated using currents J, M derived from B_source, E_source.
                 * The soft source scheme (in equivalent TF/SF formulation) is implemented in incidentField
                 * and is explained there in more detail.
                 *
                 * However, the laser in question operates differently.
                 * We merely fit the coefficient so that the combination of source application and field solver
                 * produces expected values in the y > T_initPlaneY area.
                 * Our coefficient value matches that in (33) with alpha = 2 in M. Mansourabadi, A. Pourkazemi.
                 * FDTD Hard Source and Soft Source Reviews and Modifications.
                 * Progress In Electromagnetics Research C, Vol. 3, 143-160, 2008. doi:10.2528/PIERC08032302.
                 * (However they unconventionally call this scheme simply "soft source").
                 * Similarly to the hard source, the scheme implies the laser-induced B values are odd wrt the source.
                 * Same as in the previous case, all grid values with y >= 0 will be updated by a field solver.
                 * There will be a left-propagating wave in the 0 <= y < T_initPlaneY area generated by the source.
                 * This area should normally be excluded when analysing the results.
                 * A field absorber should be used at the y_min border to avoid significant influence of this region
                 * on the rest of the simulation volume.
                 * Note that unlike the hard source case, this source is transparent for incoming waves.
                 * Same as the hard-source case, this scheme is fully accurate only for the classic Yee solver.
                 *
                 * @tparam T_initPlaneY laser initialization plane in y,
                 *                      value in cells in the global coordinates
                 */
                template<uint32_t T_initPlaneY>
                class BaseFunctor
                {
                public:
                    //! Type of data box for field E
                    using DataBoxE = typename FieldE::DataBoxType;

                    /** Device-side constructor
                     *
                     * @param dataBoxE global data box for field E
                     * @param superCellToLocalOriginCellOffset offset of the active supercell to the local domain
                     * origin; in cells, does not account for guards
                     * @param offsetToTotalDomain offset of local domain to total domain, in cells
                     * @param elong initial laser-induced value of E
                     */
                    HDINLINE BaseFunctor(
                        DataBoxE const& dataBoxE,
                        DataSpace<simDim> const& superCellToLocalOriginCellOffset,
                        DataSpace<simDim> const& offsetToTotalDomain,
                        float3_X const& elong)
                        : m_dataBoxE(dataBoxE)
                        , m_superCellToLocalOriginCellOffset(superCellToLocalOriginCellOffset)
                        , m_offsetToTotalDomain(offsetToTotalDomain)
                        , m_elong(elong)
                    {
                    }

                    /** Contribute the value stored in m_elong (calculated by a child class) to the grid value of E
                     *
                     * The way of contributing depends on whether T_initPlaneY == 0.
                     * However, the difference is contained here, it does not affect calculating m_elong.
                     *
                     * @param localCell index of a local cell in the local domain (without guards)
                     */
                    HDINLINE void operator()(DataSpace<simDim> const& localCell)
                    {
                        // Take into account guard, as m_dataBoxE is stored like that
                        auto const gridIdx = localCell + SuperCellSize::toRT() * GuardSize::toRT();
                        if(T_initPlaneY != 0)
                        {
                            /* Mixed hard-soft mode.
                             * This coefficient was found by PIConGPU developers independently, but matches
                             * one in the paper by M. Mansourabadi & A. Pourkazemi referenced in the comment above.
                             * The meaning of this coefficient is also explained there in more detail.
                             */
                            auto const coefficient = (SPEED_OF_LIGHT * maxwellSolver::getTimeStep()) / CELL_HEIGHT * 2._X;
                            m_dataBoxE(gridIdx) += coefficient * m_elong;
                        }
                        else
                        {
                            // Hard source mode
                            m_dataBoxE(gridIdx) = m_elong;
                        }
                    }

                public:
                    //! Global data box for field E
                    DataBoxE m_dataBoxE;

                    /** Offset of the active supercell to the local domain origin
                     *
                     * In cells, does not account for guards.
                     */
                    DataSpace<simDim> m_superCellToLocalOriginCellOffset;

                    //! Offset of local domain to total domain, in cells
                    DataSpace<simDim> m_offsetToTotalDomain;

                    /** Laser-induced value of E
                     *
                     * To be modified by child classes before calling operator().
                     */
                    float3_X m_elong;
                };

            } // namespace acc
        } // namespace laserProfiles
    } // namespace fields
} // namespace picongpu
